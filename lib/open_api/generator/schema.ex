defmodule OpenAPI.Generator.Schema do
  alias OpenAPI.Generator.Render
  alias OpenAPI.Spec

  @spec write_all(OpenAPI.Generator.State.t()) :: [{module, String.t()}]
  def write_all(state) do
    File.mkdir_p!(state.options.base_location)
    schemas = Enum.take(state.schemas, 2)

    for {_name, module, spec} <- schemas do
      module = Module.concat(state.options.base_module, module)
      filename = Path.join(state.options.base_location, Macro.underscore(module) <> ".ex")
      docstring = docstring(spec)
      types = types(state, spec)
      fields = fields(state, spec)
      decoders = decoders(state, spec)

      file =
        Render.schema(
          module: module,
          docstring: docstring,
          types: types,
          fields: fields,
          decoders: decoders
        )
        |> Code.format_string!()

      File.mkdir_p!(Path.dirname(filename))
      File.write!(filename, [file, "\n"])
      {module, filename}
    end
  end

  # defp primitive_type?(%Spec.Schema{type: "array"}), do: true
  # defp primitive_type?(%Spec.Schema{type: "boolean"}), do: true
  # defp primitive_type?(%Spec.Schema{type: "integer"}), do: true
  # defp primitive_type?(%Spec.Schema{type: "string"}), do: true
  # defp primitive_type?(_), do: false

  defp docstring(%Spec.Schema{title: title, description: description}) do
    """
    #{title || description}

    Generated by OpenAPI Generator. Avoid editing this file directly.\
    """
  end

  defp types(state, %Spec.Schema{properties: properties}) do
    Enum.map(properties, fn {name, spec_or_ref} ->
      {name, type(state, spec_or_ref)}
    end)
    |> Enum.sort_by(fn {name, _type} -> name end)
  end

  defp type(state, %Spec.Schema{type: "array", items: items}) do
    ["[", type(state, items), "]"]
  end

  defp type(_state, %Spec.Schema{type: "boolean"}), do: "boolean"
  defp type(_state, %Spec.Schema{type: "integer"}), do: "integer"
  defp type(_state, %Spec.Schema{type: "object"}), do: "map"
  defp type(_state, %Spec.Schema{type: "string"}), do: "String.t()"

  defp type(state, %Spec.Ref{"$ref": "#/components/schemas/" <> schema_name}) do
    # TODO: ignored schemas -> map
    case Enum.find(state.schemas, fn {name, _module, _spec} -> name == schema_name end) do
      {_name, module, _spec} ->
        Module.concat(state.options.base_module, module)
        |> inspect()
        |> to_string()
        |> Kernel.<>(".t()")

      nil ->
        "map"
    end
  end

  defp fields(_state, %Spec.Schema{properties: properties}) do
    Enum.map(properties, fn {name, _spec_or_ref} -> name end)
    |> Enum.sort()
  end

  defp decoders(state, %Spec.Schema{properties: properties}) do
    Enum.map(properties, fn {name, spec_or_ref} ->
      decoder =
        decoder(state, name, spec_or_ref)
        |> Macro.to_string()

      {name, decoder}
    end)
    |> Enum.sort_by(fn {name, _decoder} -> name end)
  end

  defp decoder(_state, _name, %Spec.Schema{type: "array", items: _items}) do
    quote do
      nil
    end
  end

  defp decoder(_state, name, %Spec.Schema{type: _}) do
    quote do
      value[unquote(name)]
    end
  end

  defp decoder(state, name, %Spec.Ref{"$ref": "#/components/schemas/" <> schema_name}) do
    case Enum.find(state.schemas, fn {name, _module, _spec} -> name == schema_name end) do
      {_name, module, _spec} ->
        mod = Module.concat(state.options.base_module, module)

        quote do
          unquote(mod).decode(value[unquote(name)])
        end

      nil ->
        quote do
          value[unquote(name)]
        end
    end
  end
end
