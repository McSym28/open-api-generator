defmodule OpenAPI.Generator.Schema do
  alias OpenAPI.Generator.Render
  alias OpenAPI.Spec

  @spec write_all(OpenAPI.Generator.State.t()) :: [{module, String.t()}]
  def write_all(state) do
    File.mkdir_p!(state.options.base_location)

    for {_name, {module, spec}} <- state.schemas, complex_type?(spec) do
      module = Module.concat(state.options.base_module, module)
      filename = Path.join(state.options.base_location, Macro.underscore(module) <> ".ex")
      docstring = docstring(spec)
      fields = fields(state, spec)

      file =
        Render.schema(
          module: module,
          docstring: docstring,
          fields: fields
        )
        |> Code.format_string!()

      File.mkdir_p!(Path.dirname(filename))
      File.write!(filename, [file, "\n"])
      {module, filename}
    end
  end

  defp complex_type?(%Spec.Schema{type: nil}), do: false
  defp complex_type?(%Spec.Schema{type: "boolean"}), do: false
  defp complex_type?(%Spec.Schema{type: "integer"}), do: false
  defp complex_type?(%Spec.Schema{type: "number"}), do: false
  defp complex_type?(%Spec.Schema{type: "string"}), do: false
  defp complex_type?(%Spec.Schema{any_of: any_of}) when is_list(any_of), do: false
  defp complex_type?(%Spec.Schema{one_of: one_of}) when is_list(one_of), do: false
  defp complex_type?(_), do: true

  defp docstring(%Spec.Schema{title: title, description: description}) do
    """
    #{title || description || "Generated Schema"}

    Generated by OpenAPI Generator. Avoid editing this file directly.\
    """
  end

  defp fields(state, %Spec.Schema{properties: properties}) do
    Enum.map(properties, fn {name, spec_or_ref} ->
      {name, type(state, spec_or_ref)}
    end)
    |> Enum.sort_by(fn {name, _type} -> name end)
  end

  defp type(state, spec, name \\ nil)

  defp type(state, %Spec.Schema{type: "array", items: items}, _name) do
    {:array, type(state, items)}
  end

  defp type(_state, %Spec.Schema{type: "boolean"}, _name), do: :boolean
  defp type(_state, %Spec.Schema{type: "integer"}, _name), do: :integer
  defp type(_state, %Spec.Schema{type: "number"}, _name), do: :number
  defp type(_state, %Spec.Schema{type: "string"}, _name), do: :string

  defp type(state, %Spec.Schema{type: "object"}, name) do
    if name do
      Module.concat(state.options.base_module, name)
    else
      :map
    end
  end

  defp type(_state, %Spec.Schema{any_of: any_of}, _name) when is_list(any_of), do: :unknown
  defp type(_state, %Spec.Schema{one_of: one_of}, _name) when is_list(one_of), do: :unknown
  defp type(_state, %Spec.Schema{type: nil}, _name), do: :unknown

  defp type(state, %Spec.Ref{"$ref": "#/components/schemas/" <> schema_name}, _name) do
    # TODO: ignored schemas -> map
    case Map.get(state.schemas, schema_name) do
      {module, spec} -> type(state, spec, module)
      nil -> :map
    end
  end
end
