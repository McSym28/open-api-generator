defmodule OpenAPI.Generator.Schema do
  alias OpenAPI.Spec
  alias OpenAPI.Util

  @spec process(%OpenAPI.State{}) :: [{module, OpenAPI.State.file()}]
  def process(state) do
    for {module, spec} <- state.schemas do
      filename =
        Path.join([
          state.options.base_location,
          state.options.schema_location,
          Macro.underscore(module) <> ".ex"
        ])

      module = Module.concat(state.options.base_module, module)
      docstring = docstring(spec)
      fields = fields(state, spec)

      {module, %{name: filename, docstring: docstring, fields: fields, operations: []}}
    end
  end

  defp docstring(%Spec.Schema{title: title, description: description}) do
    """
    #{title || description || "Generated Schema"}

    Generated by OpenAPI Generator. Avoid editing this file directly.\
    """
  end

  defp fields(state, %Spec.Schema{properties: properties}) do
    Enum.map(properties, fn
      {field_name, %Spec.Schema{} = schema} ->
        schema_name = Util.referenced_name(state, schema)
        {field_name, type(state, schema, schema_name)}

      {field_name, spec} ->
        {field_name, type(state, spec)}
    end)
    |> Enum.sort_by(fn {name, _type} -> name end)
  end

  def type(state, spec, name \\ nil)

  def type(state, %Spec.Schema{type: "array", items: %Spec.Schema{} = schema}, _name) do
    schema_name = Util.referenced_name(state, schema)
    {:array, type(state, schema, schema_name)}
  end

  def type(state, %Spec.Schema{type: "array", items: items}, _name) do
    {:array, type(state, items)}
  end

  def type(_state, %Spec.Schema{type: "boolean"}, _name), do: :boolean
  def type(_state, %Spec.Schema{type: "integer"}, _name), do: :integer
  def type(_state, %Spec.Schema{type: "number"}, _name), do: :number
  def type(_state, %Spec.Schema{type: "string"}, _name), do: :string

  def type(state, %Spec.Schema{type: "object"}, name) do
    if name do
      Module.concat(state.options.base_module, name)
    else
      :map
    end
  end

  def type(_state, %Spec.Schema{any_of: any_of}, _name) when is_list(any_of), do: :unknown
  def type(_state, %Spec.Schema{one_of: one_of}, _name) when is_list(one_of), do: :unknown
  def type(_state, %Spec.Schema{type: nil}, _name), do: :unknown

  def typespec(state, spec, name \\ nil)

  def typespec(state, %Spec.Schema{type: "array", items: items}, _name) do
    "[#{typespec(state, items)}]"
  end

  def typespec(_state, %Spec.Schema{type: "boolean"}, _name), do: "boolean"
  def typespec(_state, %Spec.Schema{type: "integer"}, _name), do: "integer"
  def typespec(_state, %Spec.Schema{type: "number"}, _name), do: "number"
  def typespec(_state, %Spec.Schema{type: "string"}, _name), do: "String.t()"

  def typespec(state, %Spec.Schema{type: "object"}, name) do
    if name do
      inspect(Module.concat(state.options.base_module, name)) <> ".t()"
    else
      "map"
    end
  end

  def typespec(_state, %Spec.Schema{any_of: any_of}, _name) when is_list(any_of), do: :unknown
  def typespec(_state, %Spec.Schema{one_of: one_of}, _name) when is_list(one_of), do: :unknown
  def typespec(_state, %Spec.Schema{type: nil}, _name), do: :unknown
end
